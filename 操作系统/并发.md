### 进程和线程的区别
1. 地址空间保持不变（即不需要切换当前使用的页表）
2. 多线程 堆共享，栈私有
#### 多线程导致的后果
![[1750052768750_d.png]]

![[1750053080787_d.png]]

![[1750053908344_d.png]]
运行时每个线程都有自己的专用寄存器。上下文切换代码将寄存器虚拟化（virtualized），保存并恢复它们的值

假设 线程1开始执行counter值被加载到eax里面（50），向寄存器加1，eax=51,   然后发生了时钟中断，把程序计数器，寄存器等一堆值存到线程控制块里面    
线程2来了，counter还是50，执行完以后变成51，
然后又开始执行线程1了，又把eax=51写到counter里面去了
相当于线程1白干

#### 线程API

![[1750056899085_d.png]]

![[1750057296595_d.png]]

等待线程完成：pthread_join()
![[1750060617098_d.png]]

int pthread_code_wait(pthread_code_t * cond,pthread_mutex_t * mutex);
%% 调用线程进入休眠状态 %%
int pthread_code_signal(pthread_cond * cond)

#### 锁
##### 正确示范
###### 测试并设置
最简单的硬件支持是<mark style="background: #BBFABBA6;">测试并设置指令</mark>（原子交换）
![[1750211577366_d.png]]
这段大概描述了硬件实现的原子性操作
怎么用它实现锁
![[1750212550033_d.png]]

注意：不提供任何公平性保证，可能会导致饿死
单CPU，自旋效果差
在多CPU上，自旋锁性能不错（如果线程数大致等于CPU数）。

###### <mark style="background: #BBFABBA6;">比较并交换</mark>
![[1750222280789_d.png]]
###### <mark style="background: #BBFABBA6;">链接的加载和条件式存储</mark>
![[1750222544281_d.png]]
只有上一次加载的地址在期间都没有更新时，才会成功，（同时更新刚才链接的加载的地址的值）。成功时，条件存储返回1，并将ptr指的值更新为value。失败时，返回0，并且不会更新值。

![[1750223085397_d.png]]

###### 获取并增加
保证了每个线程都能运行完，但是自旋浪费CPU
![[1750230027638_d.png]]



###### 使用队列 休眠，等锁空闲唤醒
![[1750232594623_d 1.png]]

Linux的操作
```c
void mutex_lock(int * mutex){
	int v;
	if(atomic_bit_test_set(mutex,31)==0) //最高位为0 表示锁空闲
		return;
	atomic_increment(mutex);
	while(1){
		if(atomic_bit_test_set(mutex,31)==0){
			atomic_decrement(mutex);
			return;
		}
		v=*mutex;
		if(v>0)
			continue;
		futex_wait(mutex,v);
	}
}

void mutex_unlock(int *mutex){
	if(atomic_add_zero(mutex,0x80000000))   //如果加上结果是0
		return;
	futex_wake(mutex);
}

```


##### 错误示范

没有实现互斥 而且耗费性能
![[1750211009034_d.png]]

### 基于锁的并发数据结构
#### 并发计数器
##### <mark style="background: #BBFABBA6;">无锁的</mark>

![[1750318696507_d.png]]

##### <mark style="background: #BBFABBA6;">有锁的 版本1</mark>

![[1750318766360_d.png]]

但是并发情况下速度很慢
##### 版本二
![[1750319003866_d.png]]

##### 链表锁
![[1750321217685_d.png]]
![[1750321266966_d.png]]

##### 队列锁
![[964de766b19569ec5d935224748f435.jpg]]
![[1750384780604_d.png]]
```c
43                                     pthread_mutex_unlock(&q->headLock);
44                                     free(tmp);
45                                     return 0;
```

注意，初始化时候就新增了一个假节点  
**如果队列中只有一个有效节点（即 `dummy->next` 指向一个真实节点），并发执行 `Enqueue` 和 `Dequeue` 时可能会出现问题**。

##### 哈希表锁
![[1750388267443_d.png]]

### 条件变量
![[1750407006800_d.png]]


### **`pthread_cond_wait`**
1. **原子地释放锁并阻塞线程**，直到被唤醒。
2. **被唤醒后重新获取锁**，再继续执行。